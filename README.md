                        **Rapport de TP ** *(Implémentation d'une version naïve de l'algorithme de DIJKSTRA)* 
 
 **1/Introduction ** 
 
 -->Le TP consiste à implémenter une version naïve de l'algorithme de DIJKSTRA et en comparer les résultats avec les résultats de la version 
 
 Graph Stream de l'algorithme DIJKSTRA sur le même graphe. 
 
 -->Pour bien comparer les résultats des deux versions de l'algorithme de DIJKSTRA on doit comparer plusieurs graphes avec des tailles différentes,
 
 il est préférable de comparer l'exécution de l'algorithme sur des graphes d'une grande taille pour assurer le fonctionnement de la version naive 
 
 de l'algorithme de dijkstra qu'on doit développer. 
 
 
 -->Pour bien comparer les deux versions de l'algorithme de DIJKSTRA on doit comparer l'exécution des deux versions de l'algorithme sur le même
 
 graphe, et de préférence un graphe qui a une grande taille (1000 noeuds ou plus par exemple). 
 
 
 **2/Structure de programme**
 
  -->Pour l'implémentation de l'algorithme on a utilisé trois classes réparties dans deux fichiers (.java) : 
  
     
       > 1/Les deux classes (Dijkstra et Graphe): 
       
        ->Ces deux classes nous permettent d'imlémenter et de tester la version naive de l'algorithme de Dijkstra, la classe (Graphe) nous permet 
         
        de créer le graphe et lui appliquer l'algorithme de dijkstra qu'on a implémenté, alors que la classe (Dijkstra) nous permet de tester notre
        
        algorithme qu'on a implémenté dans la classe (Graphe). 
        
        
        > 1/La classes (RandomGraph):
        
        ->Cette classe nous permet de générer un graphe aléatoirement en utilisant les (méthodes/fonctions) de GraphStream, le graphe généré on 
        
        lui applique les méthodes de la classe (Dijkstra) de Graph Stream pour avoir le plus petit chemin de la source vers un noeud spécifique de
        
        graphe généré.
        
        
**2/Le générateur des graphes (RandomGenerator()) de GraphStream**  

   -->Ce générateur nous permet de générer des graphes de différentes tailles aléatoirement ce qui nous facilite la comparaison des deux versions 
   
   de l'algorithme de DIJKSTRA en utilisant un graphe d'une grande taille.
   
   -->Ce générateur nous permet d'avoir un graphe avec le nombre de noeuds qu'on veut et le degré moyen de chaque noeuds ce qui nous permet d'avoir
   
   une certaine densité de connexions entre les noeuds.
   
   -->On peut aussi récupérer le graphe généré aléatoirement par RandomGenerator() de GraphStream et le stocker sous forme d'un fichier (.dgs)
   
   -->Le graphe généré aléatoirement et stocké dans un fichier (.dgs) est filtré pour en extraire les Noeuds et les arcs aussi les poids des arêtes
   
   afin de comparer les deux versions de l'algorithme de DIJKSTRA sur le même graphe pour avoir les meilleurs résultats possibles.
   
   -->Ce générateur affecte un seul poids pour toutes les arêtes, et pour les ars entre deux noeuds il les affecte aléatoirement selon le degré 
   
   moyen de chaque noeud (le nombre de ses arêtes dont il fait partie de l'une de ses extrémités).
   
 
**3/Le fonctionnement de l'algorithme implémenté**   
   
  -->L'algoritme de DIJKSTRA qu'on a implémenté fait partie de la classe Graphe.
  
  -->La classe (Graphe) comporte deux sous classes qui sont (Noeud et Arc) car un graphe donné est constitué de Noeuds et d'arcs, en plus des 
  
  différentes méthodes et fonctions incluses dans la classe (Graphe). 
  
  
 > Le fonctionnement des méthodes et fonctions de la classe (Graphe):
 
  ** 1/La classe (Arc):** Cette classe est définie par trois paramètre (les deux noeuds des extrémités et la distances entre eux), et elle permet 
  de joindre deux noeuds.
   
  ** 2/La classe (Noeud ):** cette classe nous permet de définir un noeud alors un noeud est défini par (son nom qui est une chaîne de caractères,
  
  sa distance d'un autre Noeud de (Graphe), ses voisins qui sont sous forme d'un HashMap et son noeud précédent).
  
  -->*La méthode printPath()* de la classe (Noeud) nous permet d'afficher le chemin depuis le Noeud précédent d'un noeud donné.
    
  -->*La fonction compareTo()* de la classe (Noeud) nous permet de comparer la distance entre deux Noeuds différents de (Graphe). Elle retourne la 
    
    distance sous forme d'un entier.
    
  -->*La fonction equals()* de la classe (Noeud) qui est en vrai une fonction de l'interface (Comparable) implémentée par la classe (Noeud), cette 
    
    méthode nous permet de comparer entre deux Noeuds s'ils sont équivalents (nom, les voisins et la distance entre un noeud et son noeud 
    
    précédent), elle retourne true si c'est le cas.
    
  -->*La fonction hashCode()* de la classe (Noeud) qui est en vrai une fonction de l'interface (Comparable) implémenté par la classe (Noeud),cette
    
    fonction nous permet de  digérer les données stockées dans une instance de la classe dans une valeur de hachage (en un entier signé 32-bit), 
    
    elle return un entier (result).
    
  -->*La fonction toString()* de la classe (noeud) qui fait partie de l'interface (Comparable), elle est implémentée par la classe (Noeud) et elle 
  
    nous retourne le nom de noeud et la distance depuis le Noeud précédent.
    
    
** 3/La classe principale (Graphe):**

  -->`Les méthodes et fonctions de la classe (Graphe):
  `
  
  -->*Le constructeur Graphe(Arc[] arcs)()*:il nous permet de construire un (Graphe) à partir d'un tableau d'arcs passé en paramètres en ajoutant
  
   des (Noeuds) aux extrémités des (Arcs).
   
   
  -->*La fonction dijkstra(String nomSource)*: cette fonction nous retourner un Arbre (TreeSet<>) contenant tout les (Noeuds) menant de la source
  
   vers un (Noeud) précis sans ordre afin de faciliter la tâche de les organiser en fonctions de leur distance depuis le (Noeud) source qui 
   
   représente le sommet de l'arbre.
   
   
  -->*La méthode dijkstra(final NavigableSet<Noeud> q)*:c'est cette méthode aui fait tout le travaille, elle permet d'exploiter l'Arbre retourné
  
   par la fonction précédente (dijkstra(String nomSource)), cette méthode nous permet aussi de supprimer les Noeuds inaccessibles. On parcourt 
   
   l'arbre depuis la source  vers un (Noeud) précis, passant par les différents (Noeuds) menant vers ce (Noeud) destinataire, puis on compare les
   
   diffétrentes distances de chemin de (Noeud) source vers le (Noeud) destinataire, et comme dernière étape on supprime les noeuds dont le chemin
   
   en passant par est long et on garde le chemin le plus court et on garde ses (Noeuds).
   
  
  -->*La méthode ecrireChemin()*:cette méthode nous permet d'afficher le chemin depuis le (Noeud) source vers le (Noeud) destinataire. 
  
  
  -->*La méthode printAllPaths()*:cette méthode nous permet d'afficher tout les chemin depuis le (Noeud) source vers tout les (Noeuds) de (Graphe)
   
  
  
   
    
    
    
    
    
    
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
        
        
        
        















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































