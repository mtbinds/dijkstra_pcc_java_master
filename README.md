                        **Rapport de TP ** *(Implémentation d'une version naïve de l'algorithme de DIJKSTRA)* 
 
 **1/Introduction ** 
 
 -->Le TP consiste à implémenter une version naïve de l'algorithme de DIJKSTRA et en comparer les résultats avec les résultats de la version 
 
 Graph Stream de l'algorithme DIJKSTRA sur le même graphe. 
 
 -->Pour bien comparer les résultats des deux versions de l'algorithme de DIJKSTRA on doit comparer plusieurs graphes avec des tailles différentes,
 
 il est préférable de comparer l'exécution de l'algorithme sur des graphes d'une grande taille pour assurer le fonctionnement de la version naive 
 
 de l'algorithme de dijkstra qu'on doit développer. 
 
 
 -->Pour bien comparer les deux versions de l'algorithme de DIJKSTRA on doit comparer l'exécution des deux versions de l'algorithme sur le même
 
 graphe, et de préférence un graphe qui a une grande taille (1000 noeuds ou plus par exemple). 
 
 
 **2/Structure de programme**
 
  -->Pour l'implémentation de l'algorithme on a utilisé trois classes réparties dans deux fichiers (.java) : 
  
     
       > 1/Les deux classes (Dijkstra et Graphe): 
       
        ->Ces deux classes nous permettent d'imlémenter et de tester la version naive de l'algorithme de Dijkstra, la classe (Graphe) nous permet 
         
        de créer le graphe et lui appliquer l'algorithme de dijkstra qu'on a implémenté, alors que la classe (Dijkstra) nous permet de tester notre
        
        algorithme qu'on a implémenté dans la classe (Graphe). 
        
        
        > 1/La classe (RandomGraph):
        
        ->Cette classe nous permet de générer un graphe aléatoirement en utilisant les (méthodes/fonctions) de GraphStream, le graphe généré on 
        
        lui applique les méthodes de la classe (Dijkstra) de Graph Stream pour avoir le plus petit chemin de la source vers un noeud spécifique de
        
        graphe généré.
        
        
**3/Le générateur des graphes (RandomGenerator()) de GraphStream**  

   -->Ce générateur nous permet de générer des graphes de différentes tailles aléatoirement ce qui nous facilite la comparaison des deux versions 
   
   de l'algorithme de DIJKSTRA en utilisant un graphe d'une grande taille.
   
   -->Ce générateur nous permet d'avoir un graphe avec le nombre de noeuds qu'on veut et le degré moyen de chaque noeuds ce qui nous permet d'avoir
   
   une certaine densité de connexions entre les noeuds.
   
   -->On peut aussi récupérer le graphe généré aléatoirement par RandomGenerator() de GraphStream et le stocker sous forme d'un fichier (.dgs)
   
   -->Le graphe généré aléatoirement et stocké dans un fichier (.dgs) est filtré pour en extraire les Noeuds et les arcs aussi les poids des arêtes
   
   afin de comparer les deux versions de l'algorithme de DIJKSTRA sur le même graphe pour avoir les meilleurs résultats possibles.
   
   -->Ce générateur affecte un seul poids pour toutes les arêtes, et pour les ars entre deux noeuds il les affecte aléatoirement selon le degré 
   
   moyen de chaque noeud (le nombre de ses arêtes dont il fait partie de l'une de ses extrémités).
   
 
**4/Le fonctionnement de l'algorithme implémenté**   
   
  -->L'algoritme de DIJKSTRA qu'on a implémenté fait partie de la classe Graphe.
  
  -->La classe (Graphe) comporte deux sous classes qui sont (Noeud et Arc) car un graphe donné est constitué de Noeuds et d'arcs, en plus des 
  
  différentes méthodes et fonctions incluses dans la classe (Graphe). 
  
  
 > Le fonctionnement des méthodes et fonctions de la classe (Graphe):
 
  ** 1/La classe (Arc):** Cette classe est définie par trois paramètre (les deux noeuds des extrémités et la distances entre eux), et elle permet 
  de joindre deux noeuds.
   
  ** 2/La classe (Noeud ):** cette classe nous permet de définir un noeud alors un noeud est défini par (son nom qui est une chaîne de caractères,
  
  sa distance d'un autre Noeud de (Graphe), ses voisins qui sont sous forme d'un HashMap et son noeud précédent).
  
  -->*La méthode printPath()* de la classe (Noeud) nous permet d'afficher le chemin depuis le Noeud précédent d'un noeud donné.
    
  -->*La fonction compareTo()* de la classe (Noeud) nous permet de comparer la distance entre deux Noeuds différents de (Graphe). Elle retourne la 
    
    distance sous forme d'un entier.
    
  -->*La fonction equals()* de la classe (Noeud) qui est en vrai une fonction de l'interface (Comparable) implémentée par la classe (Noeud), cette 
    
    méthode nous permet de comparer entre deux Noeuds s'ils sont équivalents (nom, les voisins et la distance entre un noeud et son noeud 
    
    précédent), elle retourne true si c'est le cas.
    
  -->*La fonction hashCode()* de la classe (Noeud) qui est en vrai une fonction de l'interface (Comparable) implémenté par la classe (Noeud),cette
    
    fonction nous permet de  digérer les données stockées dans une instance de la classe dans une valeur de hachage (en un entier signé 32-bit), 
    
    elle return un entier (result).
    
  -->*La fonction toString()* de la classe (noeud) qui fait partie de l'interface (Comparable), elle est implémentée par la classe (Noeud) et elle 
  
    nous retourne le nom de noeud et la distance depuis le Noeud précédent.
    
    
** 3/La classe principale (Graphe):**

  -->`Les méthodes et fonctions de la classe (Graphe):
  `
  
  -->*Le constructeur Graphe(Arc[] arcs)()*:il nous permet de construire un (Graphe) à partir d'un tableau d'arcs passé en paramètres en ajoutant
  
   des (Noeuds) aux extrémités des (Arcs).
   
   
  -->*La fonction dijkstra(String nomSource)*: cette fonction nous retourner un Arbre (TreeSet<>) contenant tout les (Noeuds) menant de la source
  
   vers un (Noeud) précis sans ordre afin de faciliter la tâche de les organiser en fonctions de leur distance depuis le (Noeud) source qui 
   
   représente le sommet de l'arbre.
   
   
  -->*La méthode dijkstra(final NavigableSet<Noeud> q)*:c'est cette méthode aui fait tout le travaille, elle permet d'exploiter l'Arbre retourné
  
   par la fonction précédente (dijkstra(String nomSource)), cette méthode nous permet aussi de supprimer les Noeuds inaccessibles. On parcourt 
   
   l'arbre depuis la source  vers un (Noeud) précis, passant par les différents (Noeuds) menant vers ce (Noeud) destinataire, puis on compare les
   
   diffétrentes distances de chemin de (Noeud) source vers le (Noeud) destinataire, et comme dernière étape on supprime les noeuds dont le chemin
   
   en passant par est long et on garde le chemin le plus court et on garde ses (Noeuds).
   
  
  -->*La méthode ecrireChemin()*: cette méthode nous permet d'afficher le chemin le plus court (+Noeuds) depuis le (Noeud) source vers le (Noeud) 
  
  destinataire. 
  
  
  -->*La méthode printAllPaths()*:cette méthode nous permet d'afficher tout les chemin les plus courts depuis le (Noeud) source vers tout les 
  
  (Noeuds) de (Graphe).
  
  
  
** 5/La version de l'algorithme de DIJKSTRA de GraphStream:**
  
  
    ->Cette version comprend un nombre important de méthodes et fonctions,les principales sont:
     
     -->*La méthode init()*: elle permet de définir un graphe spécifique comme étant un graphe à qui on applique le programme de (DIJKSTRA).
   
     -->*La méthode setSource()*: elle permet de définir le (Noeud) source de graphe pour le programme de (DIJKSTRA).
     
     -->*La méthode compute()*: c'est la méthode la plus importante car elle permet d'avoir tout les courts chemins de (Noeud) source vers tout
     
        autres Noeuds de (Graphe).
        
     -->*La méthode getPath()*: cette méthode nous retourne le plus court chemin entre le (Noeud) source et un (Noeud) destinataire.
     
     
     
   --> `On Constate que la version de l'algorithme (DIJKSTRA) de GraphStream est plus pratique en terme d'appels vers les méthodes/fonctions`
   
   
** 6/Le test des deux versions d'algorithmes de (DIJKSTRA)**

  -->Pour avoir les résultats exacts on a généré à chaque fois un graphe avec la fonction (RandomGenerator()) de (GraphStream) puis on l'a stoké

  sous forme d'un fichier (graphes.dgs).

  -->On a filtré les données de fichier (graphe.dgs) pour les deux versions en reconstruisant le même (Graph) en lui appliquant les deux versions

  de l'algorithme de (DIJKSTRA).

  -->On a testé les deux algorithmes sur plusieurs (Graphes) de tailles différentes et on a eu à chaque fois les temps d'exécution des deux 

  versions de l'algorithme de (DIJKSTRA) qui sont égaux (par exemple pour un graphe de 1000 noeuds on a le temps d'exécution des deux algorithmes de

  (DIJKSTRA) est égal à 4s et 868 ms).

  -->On a testé les deux versions d'algorithme de DIJKSTRA sur plusieurs tailles de graphes (100,500,1000,2000....10000) on avait toujours les 

  temps d'exécution des deux algorithmes qui sont égaux.

  -->On a choisit de d'utiliser le même Graphe à chaque fois pour les deux algorithmes de (DIJKSTRA) pour assurer que les résultats seront les 

  plus exacts possibles.
  
  -->On a tracé une courbe pour les temps d'exécution des deux versions de l'algorithme de DIJKSTRA, la courbe se trouve dans le dépôt (GIT).
  

** 7/La comparaison des deux versions des algorithmes de (DIJKSTRA)**  
  
  -->Les deux vesrions nous permettent d'avoir les mêmes résultats, la différence entre les deux version est que la version de l'algorithme de 
  
  (DIJKSTRA) de (GraphStream) est plus pratique vu qu'elle comporte plus de méthodes et fonctions qui compressent les fonctions et méthodes de la 
  
  version naïve de l'algorithme de (DIJKSTRA) en fonctions et méthodes moins compliquées.
  
  -->On explique le même temps d'exécution des deux algorithmes par l'utilisation des listes chainées et des arbres dans les deux versions de 
  
  l'algorithme de (DIJKSTRA) dont l'accès est de même complexité temporelle pour un nombre similaire de (Noeuds).
  
  -->En terme de complexité temporelle donc on remarque que les deux algorithmes ont la même complexité temporelle.
  
  -->En terme de complexité spatiale la version de l'algorithme de (DIJKSTRA) de (GraphStream) est plus pratique vu qu'on travaille sur un grand 
  
  package et les méthodes/fonctions sont plus optimisées et il y a moins de boucles, aussi les classes internes (Noeud et Arc) de la classe 
  
  (Graphe) de la version naïve de l'algorithme de (DIJKSTRA) sont plus coûteuses en matière de mémoire, contrairement à la version de l'algorithme
  
  de (GraphStream) dont les classes sont plus optimisées en utilisant plus de méthodes/fonctions des classes supérieures.
  
  
  ** 7/Le traçage des courbes des deux versions de l'algorithme de (DIJKSTRA)**
  
  -->Pour traçer les courbes des deux versions de l'algorithme de (DIJKSTRA) on doit générer des graphes de différentes tailles (100, 500, 1000..
  
  ...10000) et stocker ces (Graphes sous format .dgs) à chaque fois, et filtrer les données pour reconstruire le (Graphe) depuis le fichier, en
  
  filtrant les données, ce qui va nous permettre de reconstruire le même (Graphe) et appliquer les deux versions de l'algorithme de (DIJKSTRA) et
  
  mesurer le temps de l'exécution de l'algorithme sur les deux versions de l'algorithme de (DIJKSTRA) puis on trace les courbes.
  
  -->En traçant les courbes on remarques que les deux versions de l'algorithme de (DIJKSTRA) ont toujours le même temps d'exécution pour un même
  
  (Graphe) d'une taille donnée.
  
  -->La courbe de l'exécution des deux (Graphes) est incluse dans le dépôt (GIT) sous le nom de (graphes.png).
  
  
  ** 8/L'exécution des deux algorithmes de (DIJKSTRA) sur un même (Graphe) plusieurs fois**
   
   -->On a remarqué que l'exécution des deux algorithmes de (DIJKSTRA) sur un même (Graphe) d'une certaine taille un certain nombre de fois donne 
   
   toujours le même temps d'exécution pour les deux algorithmes.
   
  
  ** 9/Les tests de l'algorithme de (DIJKSTRA)**
   
   -->On a testé les deux versions de l'algorithme de (DIJKSTRA) sur une machine de (8 Go de RAM et un processeur Intel i7), et les courbes
   
   tracées utilisent les données mesurées sur cette machine.
   
   
  ** 10/Les difficultés rencontrées**
  
   -->on a rencontré quelques difficultés telles que la mise en marche des différentes (méthodes/fonctions), au début on a implémenté une version
   
   plus naïve de l'algorithme de (DIJKSTRA) en utilisant uniquement des tableaux statiques ce qui rend l'algorithme trop limité, car en atteignant
   
   la taille d'un (Graphe) de 10000 (Noeuds) l'algorithme se met en erreur (OutOfMemoryBounds), qui signifie un problème de mémoire causée par
   
   les tableaux statiques.
  
  
    
  ** 11/Conclusion**
  
   -->On a implémenté une version naïve de l'algorithme de (DIJKSTRA) en utilisant  une classe (Graphe) qui inclut deux sous classes internes
   
   ce qui nous permet de comparer cette version avec la version de même algorithme de (GraphStream).
   
   -->On a utilisé les listes chaînées (LinkedList) et les Arbres (TreeSet) pour implémenter notre algorithme, car l'utilisation des tableaux 
   
   statiques est trop limitée.
   
   -->Pour comparer le temps d'exécution sur les deux versions de l'algorithme de (DIJKSTRA), on a utilisé la fonction (RandomGenerator()) de 
   
   (GraphStream) pour générer des (Graphes) puis on les stocke sous forme (graphes.dgs).
   
   -->On procède à filtrer les données de fichier (graphes.dgs) en reconstruisant le même (Graphe) à chaque fois pour tester les deux versions de
   
   l'algorithme de (DISKSTRA).
   
   -->En testant les deux versions de l'algorithme on remarque qu'elles mettent exactement le même temps pour s'exécuter ce qui signifie que les
   
   deux versions de l'algorithme de (DIJKSTRA) on la même capacité spaciale.
   
   -->La version naïve de l'algorithme de (DIJKSTRA) nous permet d'avoir le chemin le plus cours depuis un (Noeud) source vers chaque (Noeud) de
   
   notre (Graphe), pour un (Graphe) de taille donnée.
   
   -->La version naïve de l'algorithme de (DIJKSTRA) implémentée fonctionne pour une taille de (Graphe) illimitée (la seule limite est la limite
   
   définie par Java et la capacité de la machine sur laquelle l'algorithme s'exécute).
   
   -->On peut utiliser ce type d'algorithme pour faciliter la navigation (GPS) par exemple, alors que chaque adresse représente un (Noeud) et les 
   
   chemins représentent les (Arcs).
   
   -->On peut améliorer le temps d'exécution de cette version naïve de l'algorithme de (DIJKSTRA) en l'implémentant sur (Python) 
   
   
   
   
   
   
   
   
   
   
   
   
   
   
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
   
  
  
  
  
  
  
  
  
  
  
  
   
   
   
   
  
  
   
    
    
    
    
    
    
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
        
        
        
        















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































